import { Project, User } from '../types';
import { db } from '../firebaseConfig';
import {
  collection,
  doc,
  getDoc,
  setDoc,
  getDocs,
  query,
  where,
  updateDoc,
  arrayUnion,
  arrayRemove,
  or,
  deleteDoc
} from 'firebase/firestore';
import { ref, uploadBytes, getDownloadURL } from 'firebase/storage';
import { storage } from '../firebaseConfig';

const PROJECTS_COLLECTION = 'projects';
const USERS_COLLECTION = 'users';

// --- Project Services ---

// --- Helper to sanitize project data from Firestore ---
const sanitizeProject = (data: any): Project => {
  const project = {
    ...data,
    versions: data.versions?.map((v: any) => ({
      ...v,
      comments: v.commentsJson ? JSON.parse(v.commentsJson) : (v.comments || [])
    })) || [],
    collaborators: data.collaborators || []
  } as Project;

  // Sanitize currentVersionId
  if (project.versions.length > 0) {
    if (!project.currentVersionId || !project.versions.find(v => v.id === project.currentVersionId)) {
      project.currentVersionId = project.versions[project.versions.length - 1].id;
    }
  }

  return project;
};

export const getProjectsForUser = async (user: User): Promise<Project[]> => {
  try {
    // Fetch projects where user is owner OR collaborator
    // Firestore doesn't support logical OR in 'where' clauses easily for this.
    // We'll fetch both and merge.
    const ownerQuery = query(collection(db, PROJECTS_COLLECTION), where('ownerId', '==', user.id));
    const collabQuery = query(collection(db, PROJECTS_COLLECTION), where('collaborators', 'array-contains', user.email));

    const [ownerSnapshot, collabSnapshot] = await Promise.all([getDocs(ownerQuery), getDocs(collabQuery)]);

    const projectsMap = new Map<string, Project>();

    ownerSnapshot.forEach(doc => {
      projectsMap.set(doc.id, sanitizeProject(doc.data()));
    });

    collabSnapshot.forEach(doc => {
      projectsMap.set(doc.id, sanitizeProject(doc.data()));
    });

    return Array.from(projectsMap.values()).sort((a, b) => b.lastModified - a.lastModified);
  } catch (e) {
    console.error("Error fetching projects:", e);
    return [];
  }
};


export const saveProject = async (project: Project): Promise<boolean> => {
  try {
    // Firestore doesn't support nested arrays (versions[].comments[])
    // Solution: Convert the comments arrays to JSON strings for storage
    const projectData = {
      ...project,
      versions: project.versions.map(version => ({
        id: version.id,
        versionNumber: version.versionNumber,
        fileUrl: version.fileUrl,
        fileName: version.fileName,
        uploadedBy: version.uploadedBy,
        timestamp: version.timestamp,
        // Serialize comments to avoid nested array issue
        commentsJson: JSON.stringify(version.comments || [])
      }))
    };

    await setDoc(doc(db, PROJECTS_COLLECTION, project.id), projectData);
    return true;
  } catch (e) {
    console.error("Error saving project:", e);
    return false;
  }
};

export const addCollaborator = async (projectId: string, email: string): Promise<Project | null> => {
  try {
    const projectRef = doc(db, PROJECTS_COLLECTION, projectId);

    await updateDoc(projectRef, {
      collaborators: arrayUnion(email.toLowerCase())
    });

    // We can't easily return the full updated object without fetching it again, 
    // but for now let's assume the caller will refresh or we can fetch it.
    // To keep it simple and consistent with previous sync API, let's fetch it.
    // Actually, to save a read, we might just return null and let the UI update optimistically or re-fetch.
    // But the UI expects the updated project.

    // Use getDoc for strong consistency
    const docSnap = await getDoc(projectRef);
    if (docSnap.exists()) {
      return sanitizeProject(docSnap.data());
    }
    return null;

  } catch (e) {
    console.error("Error adding collaborator:", e);
    return null;
  }
};

export const removeCollaborator = async (projectId: string, email: string): Promise<Project | null> => {
  try {
    const projectRef = doc(db, PROJECTS_COLLECTION, projectId);

    await updateDoc(projectRef, {
      collaborators: arrayRemove(email.toLowerCase())
    });

    // Use getDoc for strong consistency
    const docSnap = await getDoc(projectRef);
    if (docSnap.exists()) {
      return sanitizeProject(docSnap.data());
    }
    return null;

  } catch (e) {
    console.error("Error removing collaborator:", e);
    return null;
  }
};

export const updateUserPlan = async (userId: string, plan: 'free' | 'pro' | 'business'): Promise<void> => {
  try {
    const userRef = doc(db, USERS_COLLECTION, userId);
    await updateDoc(userRef, { plan });
  } catch (e) {
    console.error("Error updating user plan:", e);
  }
};

export const uploadFile = async (file: File, path: string): Promise<string | null> => {
  try {
    const storageRef = ref(storage, path);
    const snapshot = await uploadBytes(storageRef, file);
    const downloadURL = await getDownloadURL(snapshot.ref);
    return downloadURL;
  } catch (e) {
    console.error("Error uploading file:", e);
    return null;
  }
};

// --- Share Link Services ---

/**
 * Generate a random share token for project sharing
 */
export const generateShareToken = (): string => {
  return Array.from(crypto.getRandomValues(new Uint8Array(16)))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
};

/**
 * Reset project access: Generate new token AND clear all collaborators
 */
export const resetProjectAccess = async (projectId: string): Promise<Project | null> => {
  try {
    const newToken = generateShareToken();
    const projectRef = doc(db, PROJECTS_COLLECTION, projectId);

    await updateDoc(projectRef, {
      'shareSettings.shareToken': newToken,
      collaborators: []
    });

    // Fetch the updated project to ensure we have the latest state
    const docSnap = await getDoc(projectRef);
    if (docSnap.exists()) {
      return sanitizeProject(docSnap.data());
    }
    return null;
  } catch (error) {
    console.error('Error resetting project access:', error);
    return null;
  }
};

/**
 * Update project share settings
 */
export const updateProjectShareSettings = async (
  projectId: string,
  shareSettings: { enabled: boolean; accessLevel: 'view' | 'comment'; shareToken: string }
): Promise<boolean> => {
  try {
    const projectRef = doc(db, PROJECTS_COLLECTION, projectId);
    await updateDoc(projectRef, { shareSettings });
    return true;
  } catch (error) {
    console.error('Error updating share settings:', error);
    return false;
  }
};

/**
 * Get a shared project by ID and token
 */
export const getSharedProject = async (
  projectId: string,
  shareToken: string
): Promise<Project | null> => {
  try {
    const projectRef = doc(db, PROJECTS_COLLECTION, projectId);
    const projectSnap = await getDocs(query(collection(db, PROJECTS_COLLECTION), where('__name__', '==', projectId)));

    if (projectSnap.empty) {
      return null;
    }

    const projectData = sanitizeProject(projectSnap.docs[0].data());

    // Verify share token matches and sharing is enabled
    if (
      projectData.shareSettings?.enabled &&
      projectData.shareSettings.shareToken === shareToken
    ) {
      // Deserialize comments from JSON if stored that way
      if (projectData.versions) {
        projectData.versions = projectData.versions.map((v: any) => ({
          ...v,
          comments: v.commentsJson ? JSON.parse(v.commentsJson) : (v.comments || [])
        }));
      }

      // Handle migration and fallback
      if (!projectData.currentVersionId && (projectData as any).activeVersionId) {
        projectData.currentVersionId = (projectData as any).activeVersionId;
      }

      // If currentVersionId is still missing or invalid (not in versions), default to latest
      const hasValidVersion = projectData.versions?.some(v => v.id === projectData.currentVersionId);
      if (!hasValidVersion && projectData.versions && projectData.versions.length > 0) {
        // Sort by timestamp desc to find latest
        const sortedVersions = [...projectData.versions].sort((a, b) => b.timestamp - a.timestamp);
        projectData.currentVersionId = sortedVersions[0].id;
      }

      return projectData;
    }

    return null;
  } catch (error) {
    console.error('Error fetching shared project:', error);
    return null;
  }
};

export const updateProjectThumbnail = async (projectId: string, pageNumber: number): Promise<boolean> => {
  try {
    const projectRef = doc(db, PROJECTS_COLLECTION, projectId);
    await updateDoc(projectRef, {
      thumbnailPageNumber: pageNumber
    });
    return true;
  } catch (error) {
    console.error('Error updating project thumbnail:', error);
    return false;
  }
};